# Database Schema for Ask Your Feed (MVP)

This document outlines the comprehensive PostgreSQL database schema based on the PRD, planning session notes, and the specified tech stack. The schema is designed to work with twitterapi.io API.

---

## 1. List of Tables and Columns

### 1.1. authors (Global Table - No RLS)
- **x_author_id** BIGINT PRIMARY KEY CHECK (x_author_id > 0)  
  _-- Maps to `id` field from twitterapi.io User object_
- **handle** TEXT NOT NULL  
  _-- Maps to `userName` field from twitterapi.io (stored with @ prefix)_
- **display_name** TEXT  
  _-- Maps to `name` field from twitterapi.io User object_
- **last_seen_at** TIMESTAMPTZ  
  _-- Updated when posts from this author are ingested_

---

### 1.2. user_following (User-Scoped)
- **user_id** UUID NOT NULL
- **x_author_id** BIGINT NOT NULL  
  _-- References authors(x_author_id)_
- **last_checked_at** TIMESTAMPTZ  
  _-- Updated after each ingest cycle checks this author's tweets_
- **Primary Key**: (user_id, x_author_id)

**Indexes:**
- BTREE on (user_id, last_checked_at)

**Notes:**
- Populated via `/twitter/user/followings?userName={username}` endpoint
- Maximum 150 followed users per user (MVP limit)

---

### 1.3. posts (User-Scoped)
- **user_id** UUID NOT NULL
- **x_post_id** BIGINT NOT NULL CHECK (x_post_id > 0)  
  _-- Maps to `id` field from twitterapi.io Tweet object_
- **author_id** BIGINT NOT NULL  
  _-- Foreign Key referencing authors(x_author_id) ON DELETE CASCADE_
- **published_at** TIMESTAMPTZ NOT NULL  
  _-- Maps to `createdAt` field from twitterapi.io Tweet object_
- **url** TEXT NOT NULL  
  _-- Maps to `url` field from twitterapi.io Tweet object_  
  _-- CHECK: url ~ '^https?://(x|twitter)\\.com/.+/status/\\d+'_
- **text** TEXT NOT NULL  
  _-- Maps to `text` field from twitterapi.io Tweet object_  
  _-- Contains full post content including media transcripts/summaries_
- **conversation_id** BIGINT NULL  
  _-- Maps to `conversationId` field from twitterapi.io Tweet object_  
  _-- Threads are stored as separate rows; may be used for timeline view_
- **ingested_at** TIMESTAMPTZ NOT NULL  
  _-- Timestamp when post was ingested into our database_
- **first_visible_at** TIMESTAMPTZ NOT NULL  
  _-- Timestamp when post first became visible to user (for SLO tracking)_
- **edited_seen** BOOLEAN DEFAULT false  
  _-- Not actively used in MVP (twitterapi.io returns current version)_
- **ts** TSVECTOR  
  _-- For full-text search (maintenance via trigger or generated column using combined English + Polish dictionaries and unaccent)_

**Primary Key:** (user_id, x_post_id)

**Indexes:**
- BTREE on (user_id, published_at DESC)  
  _-- For date range queries in Q&A_
- BTREE on (user_id, conversation_id)  
  _-- For thread reconstruction_
- GIN on (ts)  
  _-- For full-text search_

---

### 1.4. qa_messages (User-Scoped)
- **id** CHAR(26) PRIMARY KEY  
  _-- ULID in string format (alternatively, use appropriate ULID datatype)_
- **user_id** UUID NOT NULL
- **question** TEXT NOT NULL
- **answer** TEXT NOT NULL  
  _-- Generated by LLM based on posts in date range_
- **date_from** TIMESTAMPTZ NOT NULL  
  _-- Start of date range for Q&A (default: 24h ago)_
- **date_to** TIMESTAMPTZ NOT NULL  
  _-- End of date range for Q&A (default: now)_
- **created_at** TIMESTAMPTZ NOT NULL DEFAULT now()

**Indexes:**
- BTREE on (user_id, created_at DESC)  
  _-- For history pagination_

---

### 1.5. qa_sources (User-Scoped - Junction Table)
- **qa_id** CHAR(26) NOT NULL  
  _-- References qa_messages(id)_
- **user_id** UUID NOT NULL
- **x_post_id** BIGINT NOT NULL

**Primary Key:** (qa_id, x_post_id)

**Foreign Keys:**
- FOREIGN KEY (user_id, x_post_id) REFERENCES posts(user_id, x_post_id) ON DELETE CASCADE
- *(Optionally, for enhanced integrity, a FK on (qa_id, user_id) referencing qa_messages can be added if qa_messages includes user_id)*

**Indexes:**
- BTREE on (qa_id)
- BTREE on (user_id, x_post_id)

---

### 1.6. ingest_runs (User-Scoped)
- **id** CHAR(26) PRIMARY KEY  
  _-- ULID in string format (or use an alternative ULID type)_
- **user_id** UUID NOT NULL
- **started_at** TIMESTAMPTZ NOT NULL
- **completed_at** TIMESTAMPTZ
- **status** TEXT NOT NULL CHECK (status IN ('ok','rate_limited','error'))
- **fetched_count** INT NOT NULL  
  _-- Total number of tweets fetched in this run_
- **retried** INT NOT NULL  
  _-- Number of retry attempts during this run_
- **rate_limit_hits** INT NOT NULL  
  _-- Number of 429 responses received from twitterapi.io_
- **err_text** TEXT  
  _-- Error message if status is 'error'_
- **last_cursor** TEXT  
  _-- Last pagination cursor used (for potential resume functionality)_
- **backfill_hours** INT  
  _-- Number of hours to backfill (NULL for regular 4h ingest, 24 for initial backfill)_

**Indexes:**
- BTREE on (user_id, started_at DESC)

**Notes:**
- **Removed `since_id`**: twitterapi.io doesn't support `since_id` parameter
- **Temporal filtering**: Uses `createdAt` field comparison instead of `since_id`
- **Pagination**: Uses cursor-based pagination via `cursor` and `has_next_page` fields
- **Regular ingest**: Fetches only first page (~20 tweets per followed user)
- **Backfill**: Paginates through all pages until 24h reached or `has_next_page === false`

---

## 2. Relationships Between Tables

- **authors**: Global table containing author details; referenced by posts. Populated from twitterapi.io User objects.
- **user_following**: Maps a user (user_id) to the authors (x_author_id) they follow. Populated via `/twitter/user/followings` endpoint.
- **posts**: Stores individual posts per user with a composite primary key (user_id, x_post_id); each post references an author. Populated via `/twitter/user/last_tweets` endpoint.
- **qa_messages**: Records user Q&A interactions generated by LLM.
- **qa_sources**: Junction table linking QA messages to posts; represents a many-to-many relationship between qa_messages and posts.
- **ingest_runs**: Tracks feed ingestion runs per user, including pagination state and error tracking.

---

## 3. Indexes

- **posts**:
  - BTREE on (user_id, published_at DESC) - For date range queries
  - BTREE on (user_id, conversation_id) - For thread reconstruction
  - GIN on (ts) - For full-text search
- **user_following**:
  - BTREE on (user_id, last_checked_at) - For tracking ingest progress
- **qa_messages**:
  - BTREE on (user_id, created_at DESC) - For history pagination
- **qa_sources**:
  - BTREE on (qa_id) - For source lookup
  - BTREE on (user_id, x_post_id) - For post reference
- **ingest_runs**:
  - BTREE on (user_id, started_at DESC) - For run history

---

## 4. PostgreSQL Row-Level Security (RLS) Policies

For all user-scoped tables (posts, qa_messages, qa_sources, ingest_runs, user_following), enforce strict isolation based on the current user. An example policy:

```sql
ALTER TABLE <table_name> ENABLE ROW LEVEL SECURITY;

CREATE POLICY user_isolation ON <table_name>
  USING (user_id = current_setting('app.user_id', true)::uuid);
```

Apply the above to:
- posts
- qa_messages
- qa_sources
- ingest_runs
- user_following

---

## 5. Additional Notes and Design Decisions

### 5.1. twitterapi.io API Integration

**Endpoints Used:**
- `/twitter/user/info?userName={username}` - Validate X username during registration
- `/twitter/user/followings?userName={username}` - Fetch list of followed users (max 150)
- `/twitter/user/last_tweets?userName={followed_username}&cursor={cursor}` - Fetch tweets for each followed user

**Data Mapping:**
- twitterapi.io `id` → `x_author_id` / `x_post_id` (BIGINT)
- twitterapi.io `userName` → `handle` (with @ prefix)
- twitterapi.io `name` → `display_name`
- twitterapi.io `createdAt` → `published_at`
- twitterapi.io `url` → `url`
- twitterapi.io `text` → `text` (merged with media descriptions)
- twitterapi.io `conversationId` → `conversation_id`

**Pagination Strategy:**
- Regular ingest (every 4h): Only first page per followed user
- Backfill (initial 24h): Full pagination using `cursor` and `has_next_page`
- No `since_id` support - temporal filtering via `createdAt` comparison

**Filtering Logic:**
```
Include post if:
  (isReply === false) OR (isReply === true AND inReplyToUserId === author.id)
  AND retweeted_tweet is NULL
  AND quoted_tweet is NULL
```

### 5.2. Identifier Types & Constraints

All X-specific IDs (e.g., x_post_id, x_author_id) are stored as BIGINT with a check ensuring positive values. ULIDs are used as primary keys for qa_messages and ingest_runs to benefit from time-sortability and simplified pagination.

### 5.3. Full-Text Search

The `ts` column in posts is utilized for full-text search. It is recommended to maintain this column via a generated column or trigger that uses a combination of English and Polish dictionaries along with the unaccent function.

**Example trigger:**
```sql
CREATE TRIGGER posts_ts_update BEFORE INSERT OR UPDATE ON posts
FOR EACH ROW EXECUTE FUNCTION
  tsvector_update_trigger(ts, 'pg_catalog.english', 'pg_catalog.polish', text);
```

### 5.4. Cascading Deletes

Hard deletes are enforced. Dependent records (e.g., entries in qa_sources) cascade on deletion, ensuring data consistency.

### 5.5. RLS Implementation

Row-level security policies ensure that user-scoped tables only reveal data matching the active user's ID as set via `SET LOCAL app.user_id`.

### 5.6. Media Handling

Media content (images and video transcripts/summaries) is merged into the `posts.text` field. There is no separate media table.

**Media Processing:**
- Images: Max 4 per post, converted to text via OpenRouter
- Videos: Max 90 seconds or 25 MB, transcribed to text
- Media exceeding limits are skipped without error

### 5.7. URL Constraints

The canonical URL in posts is validated with a CHECK constraint to match a pattern ensuring proper X/Twitter URL formats:
```sql
CHECK (url ~ '^https?://(x|twitter)\.com/.+/status/\d+')
```

### 5.8. Ingestion Tracking

**Ingest Process:**
1. Fetch followings via `/twitter/user/followings` (max 150)
2. For each followed user, fetch tweets via `/twitter/user/last_tweets`
3. Regular ingest: Only first page (~20 tweets)
4. Backfill: Paginate until 24h reached or `has_next_page === false`
5. Filter posts according to filtering logic
6. Update `authors.last_seen_at` and `user_following.last_checked_at`
7. Track pagination state in `ingest_runs.last_cursor`

### 5.9. Design Philosophy

The schema adheres to normalization (approximately 3NF) while supporting efficient querying, full-text search, and user isolation via RLS. This design provides a robust basis for handling user feeds, Q&A history, and ingestion tracking as demanded by the application requirements.

**Key Adaptations for twitterapi.io:**
- Cursor-based pagination instead of `since_id`
- Temporal filtering via `createdAt` field comparison
- Explicit tracking of pagination state for potential resume functionality
- Support for both regular (first page only) and backfill (full pagination) modes

---

This schema is ready to serve as the basis for database migrations in the Ask Your Feed MVP using twitterapi.io API.
